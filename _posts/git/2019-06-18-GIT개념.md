---
layout: post
title:  "[Git] Git개념 정리 "
date:   2020-01-07-18:50:00
author: 한만섭
categories: git
tags: Git 
---

* TOC
{:toc}




## 1. Git

특정 시점에서의 파일들의 상태를, 저장하고 보여주는 소프트웨어 

### 1.1. 특징 

- 개별파일 또는 프로젝트 전체를 이전 상태로 되돌릴 수 있고, 
- 시간에 따른 변경 사항을 비교해 볼 수 있고, 
- 누가 문제를 일으켰는지 추적할 수 있고, 
- 누가 언제 만들어낸 이슈인지도 알 수 있다.

***

### 1.2. 장점 

- 빠르다 
  - 다른 버전 관리 시스템과 다르게 데이터를 파일 시스템 스냅샷 형태로 취급하기 때문에 크기가 작다. 
  - 파일이 달라지지 않았다면 성능을 위해 새로 저장하지 않는다. 이전 상태의 파일에 대한 링크만 저장 
- 거의 모든 명령을 로컬에서 실행한다. 
  - 거의 모든 명령이 로컬의 파일과 데이터만 사용한다. 프로젝트의 히스토리 조회 를 로컬에서 한다. 
- 무결성 
  - 파일을 이름으로 저장하지 않고 내용과 디렉토리 구조를 이용해서 체크섬과 같은 해시 형태로 저장한다. 



## 2. git 설치

### 2.1. 설치 확인 

```bash
git --version 
```

### 2.2. 환경설정 

```bash
git config --global user.name 아이디 
git config --global user.email 이메일 주소
```

### 2.3. 환경설정 확인 

```bash
git config --list
```

### 2.4. zsh 설치 

`zsh`는 터미널의 가독성을 높혀주고, `tab`키로 자동 완성 기능을 제공한다. 

- brew 설치 

  ```bash
  $ ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
  ```

- Zsh 설치 

  ```bash
  brew install zsh 
  ```

  ![image](https://user-images.githubusercontent.com/46010705/71803857-32e7a380-30a5-11ea-88aa-77df2ded1a52.png)

- oh my zsh 

  ```bash 
  $ curl -L https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh | sh
  
  ```

- iterm2 

  ```bash 
  brew cask install iterm2
  ```

***

## 3. git 기초 

### 3.1. 저장소 만들기 

```bash
$ mkdir git-basic-education 
$ cd git-basic-education
$ git init 
```

저장소를 만드는 방법은 두가지다. 

- 기존 프로젝트를 git 저장소로 만드는 방법
- 다른 서버에 있는 저장소를 복제하는 방법 

#### 3.1.1. 기존 저장소를 clone하기 

git 저장소를 복사하고 싶을 때, `clone` 명령어를 실행하면 프로젝트 히스토리를 전부 받아온다. 

 ```bash
$ git clone <remote-url>
 ```

#### 3.1.2. 원격 저장소 추가

로컬 저장소를 만들어서 원격 저장소와 연결하는 방법이다. 

```bash
$ git remote add oriign <remote-url>
```

원격 저장소 `url`을 변경하고 싶다면 아래 명령어를 실행하면 된다. 

``` bash
$ git remote set-url origin <remote-url>
```

***

### 3.2. git 공간 

git은 아래와 같이 세개의 공간이 있다. 

![image](https://user-images.githubusercontent.com/46010705/71804556-2a906800-30a7-11ea-81a1-f8778c7a60ae.png)

#### 3.2.1. Working Directory (작업 디렉토리)

- 개발자가 파일을 추가/수정/삭제하는 공간
- 쉽게말해 `.git` 파일을 제외한 프로젝트 디렉토리 내의 모든 공간이 `Working Directory`다. 

#### 3.2.2. Staging Area (인덱스)

- 보통 `index`라고 하며 `repository`와  `Working Directory` 사이에 있는 공간 
- 파일이 **커밋 되기 전에** 모여있는 임시 저장 공간으로써 모든 파일은 이 공간을 거쳐 저장소로 옮겨지게 된다. 

#### 3.2.3. git directory(Repository)(저장소)

- git이 프로젝트의 메타데이터와 객체 대이터베이스를 저장하는 곳 (`.git`)
- `Staging Area` 에 커밋 가능한 스냅샷 형태로 `Stage` 해서 `Commit`하면 영구적인 스냅샷으로 저장된다. 
  1. `Working Directory ` 에서 파일을 수정한다. 
  2. `Staging Area` 에 파일을 `Stage` 해서 커밋 할 스냅샷을 만든다. 
  3. `Staging Area` 에 있는 파일들을 커밋해서 영구적인 스냅샷으로 저장한다. 

***

### 3.3 상태

#### 3.3.1. untracked(추적되지 않음)

- 추적되지 않은 파일은 모두 작업 디렉토리(`Working Directory`)에 있는 상태이며, 인덱스 혹은 저장소에 한번도 들어간 적이 없거나 (`ignored`)된 상태의 파일이다. 

#### 3.3.2.  unmodified(수정되지 않음) 

- 저장소에 저장된 파일이 수정되지 않은 상태를 말한다. 

#### 3.3.3. modified(수정됨)

- 이미 커밋 되었던 파일이 수정됐음을 뜻한다. 

#### 3.3.4. staged/indexed (인덱싱됨)

- 수정된 파일이 인덱스에 포함됐다면(`staging Area`에 올라갔다면 ) `staged` 된 상태라고 볼 수 있다. 
- 워킹 디렉토리의 모든 파일은 크게 `Tracked`(관리대상임)와 `Untracked`(관리대상이 아님)로 나뉜다.
- 처음 저장소를 `clone` 하면 모든 파일은 `Tracked` 이면서 `Unmodified`상태이다. 파일을  `checkout` 하고나서 아무것도 수정하지 않았기 때문
- 마지막 커밋 이후, 어떤 파일을 수정했다면 그 파일은 `Modified` 상태가 된다. 실제 커밋을 하기 위해서는 수정한 파일을 `Staged` 상태로 만들고, `Staged` 상태의 파일을 커밋한다. 이런 라이프 사이클을 계속 반복한다. 

![image](https://user-images.githubusercontent.com/46010705/71805542-da66d500-30a9-11ea-8ea5-6ea4c1e5a649.png)

- `Untracked` 에서 `git add . ` 를 하게되면 `Staged` 상태가 된다. 
- `Unmodified` 에서 파일을 수정하면 `Modified`  상태가 된다. 
- `Modified` 에서 `stage`  할 수 잇고, 
- `Staged`  에서 커밋을 하게 되면 더이상 수정한 것이 없기 때문에 `Unmodified` 로 가게된다. 
- `Unmodified` 에서 파일을 삭제하면 `Untracked` 상태가 된다.



### 3.3.5. ignored(무시됨)

`.gitignore` 혹은  `.git/info/exclude` 에 설정되어 있는 패턴에 의해 파일 또는 폴더가 무시될 수 있다. 

`Mac`  환경에서 폴더 생성시 자동 추가되는 `.DS_store`   파일을 `.gitignore` 에 추가해보자. 

```bash
$ echo .DS_Store >> .gitignore
```

***

### 3.4. 명령어 옵션

```bash
$ git add -A
$ git add --all
```

***

### 3.5. 실습

#### 3.5.1. status

- 파일의 상태를 확인하는 명령어 

  ```bash
  $ git status
  ```

  

- README.md` 파일을 생성하고, status 명령어를 입력하여 파일의 상태를 확인 

- 파일을 만드는 명령어 

  ```bash
  $ echo >> README.md
  ```

  

- 파일의 상태를 확인해보면 

  ```bash
  $ git status
  On branch master
  
  Initial commit
  
  Untracked files:
    (use "git add <file>..." to include in what will be committed)
  
          README.md
  
  nothing added to commit but untracked files present (use "git add" to track)
  ```

  ​	

#### 3.5.2. add 

- `add` 명령은 다음 커밋에 추가하기 위해 파일을 `staged` 상태로 만드는 것이다. 

  ```bash
  # 특정 파일만 add
  $ git add <path/file-name>
  
  # 모든 파일을 add
  $ git add --all
  $ git add -A
  $ git add .
  ```

  

- 아까 만든 `README.md`파일을 `staged` 상태로 만들어보면 

  ```bash
  $ git add README.md
  $ git status
  On branch master
  
  Initial commit
  
  Changes to be committed:
    (use "git rm --cached <file>..." to unstage)
  
          new file:   README.md
  ```

- `Changes to be committed` > 커밋될 변경 사항들에 `README.md`가 추가된 것을 볼 수 있다. 

- `README.md` 파일은 `tracked` 이면서 `staged` 상태이다. 

- 아직 커밋 되지 않은 파일들이 staged 상태인지 명시적으로 확인하는 방법 

  ```bash
  $ git ls-files --stage
  100644 15618ef3d06b41c09e9db5b5d0c9b8beee7183a4 0       README.md
  ```

- `README.md`파일을 수정하고 다시 저장한 후에 확인해보면 

  ```bash
  $ git ls-files --stage
  100644 501ead6f115ad5367ca9094e3dd43d05ae8df0a6 0       README.md
  ```

- 해시가 변경된 것을 확인할 수 있다. `git` 의 특징인 **무결성** 때문이다. 

  - `git` 은 파일을 저장할 때 이름이 아닌 체크섬, sha와 같은 해시형태로 저장하기 때문이다. 



## 4. 커밋

- 커밋은 파일, 폴더의 추가, 변경 사항을 저장소에 기록하는 것

### 4.1. 커밋하기 

```bash
$ git commit -m "커밋 로그 메세지 작성"
```

- 파일을 수정하고 `add` 와 `commit` 커밋 로그 메세지를 한번에 실행하면 아래와 같다. 

  ```bash
  $ git commit -a -m "커밋 로그 메세지 작성" // git commit -am
  ```

### 4.2. 조회하기 

#### 4.2.1. 커밋 해시/id

- 커밋이 만들어질 때 생기는 `SHA-1` 해시 값을 커밋 해시 혹은 커밋 id라고 부른다. 

  ```bash
  $ git log
  ```

  

#### 4.2.2. 커밋 히스토리 

- 커밋 히스토리는 저장소 내에 어떤 일이 있었는지 알려주는 중요한 단서. 

- 화면에 출력할 수 있는 최대 만큼 출력해줌. 

- 멈추고 싶다면 `q`

- 다음 커밋을 보고 싶으면 아래방향 화살표, 이전 커밋을 보고 싶으면 위 방향 화살표

- 여러 옵션을 조합한 커밋 히스토리 명령어 

  ```bash
  $ git log --all --oneline --decorate --graph -10
  * 2af686a (HEAD -> master) README.md 파일 수정1
  * d002a64 README.md 파일 추가
  ```

  - `-all ` : 모든 브랜치 
  - `oneline` : 한줄로 
  - `decorate` : 어떤 커밋을 가르키는지 
  - `graph` : 그래프 형태로 
  - `-10` : 최근 10개 이내로 
  - 모든 브랜치를 한줄로 보며 커밋을 하이라이팅해주고 그래프 형태로 10개만 보여달라.

### 4.3. 커밋 간의 차이점 

#### 4.3.1. 인덱스와 작업 디렉토리 

- 수정하고 인덱스 하지 않은 변경 사항과 인덱스를 비교해준다. 

  ```bash 
  $ git diff 
  ```

#### 4.3.2.  저장소와 인덱스 

 ```bash
$ git diff --cached
 ```

#### 4.3.3. 커밋과 커밋 

```bash
$ git diff <커밋>.. <커밋>
```



## 5. 파일 핸들링 

### 5.1. echo 

```bash
$ echo >> rm_test
```



### 5.1. 파일 삭제하기 

`git rm`명령은 작업 디렉토리와 인덱스로부터 파일을 제거해준다. 

```bash
$ echo >> rm_test
$ git rm rm_test
fatal: pathspec ' rm_test' did not match any files
```

`Untracked`파일을 없애려고 하자 `git`에서 에러를 발생시켰다. 해당 파일은 작업 디렉토리에만 존재하는 파일이기 때문이다. 

![image](https://user-images.githubusercontent.com/46010705/71863783-52340e80-3141-11ea-81a0-60809a60e850.png)

- 추적하지 않는 (스테이징 이전) 파일을 삭제할 경우 git 명령어 없이 rm을 사용하면 된다. 

  ```bash
  $ rm rm_test
  ```

  

  ![image](https://user-images.githubusercontent.com/46010705/71863846-81e31680-3141-11ea-888f-7627a9732251.png)

#### 5.1.1 인덱스에 추가된 파일 삭제하기 

- 파일을 `add` 하고, 커밋 없이 파일 삭제를 시도해 보자. 

  ```bash
  $ git add rm_test
  $ git status
  On branch master
  Changes to be committed:
    (use "git reset HEAD <file>..." to unstage)
  
          new file:   rm_test
  $ git rm rm_test
  error: the following file has changes staged in the index:
      rm_test
  (use --cached to keep the file, or -f to force removal)
  ```

- 인덱스에는 추가 되었지만 커밋하지 않은 파일이기 때문에, 인덱스에서만 제거할 것이면 `--cached` 

  ```bash
  $ git rm --cached rm_test
  ```

- 인덱스와 작업 디렉토리에서 강제로 삭제를 진행할 것이면  `-f` 옵션을 사용하라는 메세지를 출력한다. 

  ```bash
  $ git rm -f rm_test
  ```

#### 5.1.2. 커밋한 파일 지우기 

- 커밋 후 삭제를 시도해 보자. 

  ```bash
  $ git commit -m"add rm_test"
  [master fe05a8f] add rm_test
   1 file changed, 1 insertion(+)
   create mode 100644 rm_test
  $ git rm rm_test
  rm 'rm_test'
  $ git status
  On branch master
  Changes to be committed:
    (use "git reset HEAD <file>..." to unstage)
  
          deleted:    rm_test
  ```

  







### 5.2. 파일 이름 변경하기 

```bash
$ git mv <변경전 file-name> <변경 후 file-name>
```

#### 5.2.1. 파일 이름 변경 후 파일 히스토리 확인해보기 

- 커밋 후 파일 히스토리를 확인해보자. 

  ```bash
  $ git commit -m"rename test => text"
  [master 680dc7f] rename test => text
   1 file changed, 0 insertions(+), 0 deletions(-)
   rename test => text (100%)
  $ git log text
  commit 680dc7ff5cebe918c96433b93f7ff73fd55a1eea
  Author: joohee.moon <nt10547@nts-corp.com>
  Date:   Wed Nov 30 15:37:51 2016 +0900
  
      rename test => text
  ```

  

- 이름 변경 전 히스토리 보기 

  ```bash
  $ git log --follow text
  commit 680dc7ff5cebe918c96433b93f7ff73fd55a1eea
  Author: joohee.moon <nt10547@nts-corp.com>
  Date:   Wed Nov 30 15:37:51 2016 +0900
  
      rename test => text
  
  commit bcd6501142014d4c0797b2e7f206a944ef91eff6
  Author: joohee.moon <nt10547@nts-corp.com>
  Date:   Wed Nov 30 15:35:36 2016 +0900
  
      test
  ```

  

## 6. 브랜치

### 6.1. 브랜치란? (정리필요)

- 커밋 그래프에 존재하는 수많은 커밋중에 하나를 가르키고 있는 포인터 같은 존재 
- 안전하게 격리된 상태에서 무언가를 만들 때 사용된다. 
- **활성 브랜치**는 **현재 브랜치**를 나타낸다. 
- 새로운 커밋이 발생하면 브랜치는 새로운 커밋을 향하게 되는데 이것을 브랜치의 끝이라고 한다. 

### 6.2. 브랜치의 활용 

- 브랜치 만들기 

  ```bash
  $ git branch <branch-name>
  ```

- 브랜치 나열하기 

  새로운 브랜치를 만들었지만 `HEAD`라는 포인터는 아직 `master`를 가르킨다. 

  ```bash
  $ git branch 
  develop
  * master
  ```

- 브랜치 이동하기 

  ```bash
  $ git checkout <branch-name>
  ```

- 브랜치 만들면서 이동하기 

  ```bash
  $ git checkout -b <branch-name>
  ```

- 커밋하지 않은 상태에서 브랜치 이동하기 

  `develop`에서 작업한 내용을 저장하고 `master`로 `checkout`하려고 할 때 실패한다. 

  ```bash
  $ git checkout develop
  Switched to branch 'develop'
  # newfile을 열어 수정1을 입력하고 저장한다.
  $ git checkout master
  error: Your local changes to the following files would be overwritten by checkout:
          newfile
  Please commit your changes or stash them before you switch branches.
  Aborting
  ```

- 브랜치 삭제 

  ```bash
  $ git brnach -d <branch-name>
  ```

- 병합되지 않은 브랜치 삭제 

  test브랜치를 만들고 파일 생성 후 커밋하고 -d를 통해서 test브랜치를 삭제할 때 `merge`가 되지 않았다는 에러를 발생시킨다. 

  ```bash
  $ git branch -D <branch-name>
  ```



## 7. stash 

`stash` 는 작업 디렉토리와 인덱스의 현재 상태를 안전하게 저장할 수 있는 명령어이다. 

- `checkout` 명령어를 쓰고싶은데 수정한 부분이 있어서 불가능할 때 작성하던 코드를 안전한 스택에 쌓아두는 방법 
- 저장한 내용을 다른 브랜치로 옮기는 것도 충분히 가능하다. 
- 다른 브랜치에서 작업을 한 후에 다시 돌아와 복구하여 작업을 이어갈 수 있다. 



- 추적중이지 않은 파일 stash 

  ```bash
  $ echo >> newfile_1
  $ git stash
  No local changes to save
  $ git status
  On branch develop
  Untracked files:
  (use "git add <file>..." to include in what will be committed)
  	newfile_1
  nothing added to commit but untracked files present (use "git add" to track)
  ```

  `stash`가 제대로 동작하지 않은 것을 확인할 수 있다. 

- 추적중이지 않은 파일 강제 stash 

  작업 디렉토리와 인덱스의 상태가 저장되었다고 한다. 

  ```bash
  $ git stash –u
  Saved working directory and index state WIP on develop: c462496 add newfile
  HEAD is now at c462496 add newfile
  ```

### 7.1. stash list

- `stash area`에 에장되어 있는 것을 목록으로 확인하기 

  ```bash
  $ git stash list
  stash@{0}: WIP on develop: c462496 add newfile
  ```

- `stash`에 이름을 붙여 저장하기 

  ```bash
  $ git stash save <stash-name>
  ```

  New file_2를 만들고, 이름 붙여 저장하고 , `stash area `  확인해보기 

  ```bash
  $ git stash save –a add newfile_2
  Saved working directory and index state On develop: add newfile_2
  $ git stash list
  stash@{0}: on develop: add newfile_2
  stash@{1}: WIP on develop: c462496 add newfile
  ```

  이름을 정하지 않으면 `stash` 시점의 마지막 커밋 메세지로 저장되기 때문에 이름을 정해주는 것이 좋다. 

### 7.2. stash show 

- `stash`에 대한 자세한 내용 확인하기 

  ```bash
  git show stash@{0}
  ```

### 7.3. stash pop

- `stash area`(스택)의 Top값을 현재 브랜치에 적용한 뒤 목록에서 제거한다. 

  ```bash
  $ git stash pop
  On branch develop
  Changes to be committed:
    (use "git reset HEAD <file>..." to unstage)
  
          new file:   newfile_2
  
  Dropped refs/stash@{0} (5791ac1e23141b31e2e0413912f6ad5c03127d25)
  $ git stash list
  stash@{0}: WIP on develop: c462496 add newfile
  ```



### 7.4. stash apply

- `stash area` 의 Top값을 목록에서 제거하지 않음. 

  ```bash
  $ git stash apply
  ```

  

### 7.5. stash drop 

- id를 입력해주면 해당하는 stash를 삭제한다. 

  ```bash
  $ git stash drop stash@{0}
  ```

### 7.6. stash clear 

- 전부 삭제함

  ```bash
  $ git stash clear
  ```

  



## 8. 병합

[참고 사이트](https://backlog.com/git-tutorial/kr/stepup/stepup1_4.html)

브랜치는 커밋을 가리키는 포인터다. 서로 다른 두개의 브랜치가 가르키고 있는 커밋을 합치는 것을 병합( `merge`)라고한다. 

### 8.1. 브랜치 병합하기 

#### 8.1.1. 3-way merge

- `master` 브랜치에서 `develop`브랜치 만들기 

  ```bash
  $ git checkout -b develop
  ```

- 커밋하나 남기기 

  ```bash
  $ git commit -m "develop commit"
  ```

- `master`로 `checkout`

  ```bash
  $ git checkout master
  ```

- `feature/1` 브랜치 만들기 

  ```bash
  $ git checkout -b feature/1
  ```

- 커밋하나 남기기 

  ```bash
  $ git commit -m "feature/1 commit"
  ```

- 병합 시키기 

  ```bash
  $ git checkout develop
  $ git merge feature/1
  ```



![image](https://user-images.githubusercontent.com/46010705/71869584-f031d400-3155-11ea-973d-e94a1c8b8727.png)

![image](https://user-images.githubusercontent.com/46010705/71869615-0d66a280-3156-11ea-82ee-87f016ea288d.png)

![image](https://user-images.githubusercontent.com/46010705/71869656-2d966180-3156-11ea-8a73-e3ca604ca741.png)

#### 8.1.2. fast-forward merge

![image](https://user-images.githubusercontent.com/46010705/71869694-57e81f00-3156-11ea-9e3a-3640b282c986.png)

- 위와 같이 `master`에서 `bugFix`를 `merge`할 경우 `master`는 `bugfix`와 이어져 있기 때문에 앞으로 당겨오기만 하면 된다. 

- 위에서 3-way merge를 했을 때 `feature/1`가 `develop`과 이어져 있지만 뒤에 위치한 경우 `feature/1`에서 `develop`을 `merge`할 경우 그저 앞으로 당겨지기만 하면 되기 때문에 `fast-forward`방식 병합이다. 

   ```bash
  $ git checkout feature/1
   ```

  ```bash
  $ git merge develop
  ```

  ```bash
  git log --oneline --decorate --all --graph -10
  ```

  

![image](https://user-images.githubusercontent.com/46010705/71869923-4fdcaf00-3157-11ea-9e63-3a19c0970c53.png)



#### 8.1.3. 충돌 해결 

- 같은 파일을 두 브랜치에서 수정하고 merge하면, git은 해당 부분을 자동으로 merge하지 못하기 때문에 발생함. 

![image](https://user-images.githubusercontent.com/46010705/71870080-e4dfa800-3157-11ea-8850-fb46b05bf4ce.png)

- 병합하기 





## 9. 히스토리 수정하기 

- 커밋은 순서, 커밋메세지, 커밋한 파일을 변경할 수 있다. 
- 여러개의 커밋을 하나로 합치거나 하나의 커밋을 여러개의 커밋으로 분리할 수도 있다. 
- 커밋 전체를 삭제할 수도 있다. 
- 해시 값이 변경되기 때문에 원격 저장소에 저장된 커밋은 건드리지 않는 것이 좋다 .



### 9.1. commit --amend

- 마지막 커밋을 수정할 수 있는 명령어이다. 

- 파일 수정 후 아래 명령어를 쳐준다. 

  ```bash
  $ git commit --amend
  ```

- 커밋메세지를 변경하는 창이 뜬다. 수정해주면 변경된다 .



### 9.2. reset

`reset`명령어는 `HEAD`를 이전 상태로 되돌리고 과거부터 시작한다. `reset`에는 3가지 `mode`가 존재한다. 

#### 9.2.1. 작업 디렉토리를 유지하며 되돌리기 (`--mixed`)

- `--mixed`로 입력하지 않아도 기본으로 적용되는 모드이다. 작업디렉토리는 유지하면서 인덱스를 HEAD와 함께 되돌린다. 

     ```bash
  $ git reset 커밋 해시 
     ```

#### 9.2.2. 작업 디렉토리, 인덱스를 유지하며 되돌리기 (`--soft`)

- 현재의 인덱스 상태와 작업 디렉토리 내용을 그대로 보존한채 커밋만 취소한다. 

  ```bash
  $ git reset --soft 커밋 해시 
  ```

#### 9.2.3. 작업 디렉토리, 인덱스를 유지하지 않고 되돌리기 (`--hard`)

- 작업했던 내용을 의도적으로 모두 버릴 때 사용한다. 실수를 해서 특정 커밋으로 되돌리고 싶을 경우 

### 9.3. checkout 

파일 수정 후 인덱스에 추가하지 않은 상태(modified)에서 특정 파일의 작업 내역을 모두 버리고 싶을 때 사용한다.
더블 하이픈(`--`) 입력여부와 관계 없이 동일한 기능을 수행한다.

### 9.4. revert

-  `reset`에서 남지 않는 취소 이력을 만들면서 취소하는 경우에 사용한다. 

  ```bash
  $ git revert <커밋 id>
  $ git revert <커밋 id> ^..<커밋 id>
  $ git revert –m 1 <merge 커밋 id>
  ```

### 9.5. cherry-pick

- 브랜치를 통째로 merge하지 않고, 특정 커밋을 반영하고 싶을 때 사용한다. 
- `merge`방식과 마찬가지로 `conflict` 해줘야한다.
- `merge`방식은 해당 브랜치의 이력이 통째로 다 넘어가는 것.
- `cherry-pick` 은 원하는 커밋만  `pick`해서 내 브랜치에 반영하고 싶은 경우에 사용한다. 

### 9.6. rebase (정리 필요)

```bash
$ git rebase -i HEAD~<n>
i는 대화형 명령, HEAD~<n> 은 HEAD로부터 n번째 커밋까지를 뜻한다.
```





## 10. reflog 

- `git`은 자동으로 브랜치아 HEAD가 가르켰었던 커밋을 모두 기록한다. 그 중에서도 `reflog`는 내 로컬에서 일어난 일만 기록한다. 
- 확인되지 않는 지점으로 이동하고 싶을 때 매우 유용하다. 
- `reflog`가 업데이트 되는 내역 
  - `clone`
  - `push`
  - `commit`
  - `branch`
  - `rebase`
  - `reset`, `revert`
  - `checkout`



## 11. 원격(remote) 저장소

- 원격 저장소 조회 

  ```bash
  $ git remote -v
  ```

- 원격 저장소 목록 조회 

  ```bash
  $ git remote show origin 
  ```

  

- 원격 저장소에 `push`

  ```bash
  $ git push origin <branch-name>
  ```

- 원격 저장소에 강제로 `push`

  ```bash
  $ git push origin <branch-name> -f
  ```

- 원격 저장소에 브랜치 삭제

  ```bash
  $ git push origin :<branch-name>
  ```



### 11.1 fetch

로컬 저장소에는 없지만, 원격 저장소에는 있는 데이터를 모두 가져온다.

이 때 로컬의 파일 내용은 변경되지 않고 그대로 남는다. 원격 저장소의 데이터를 가져와서 저장해두고 사용자가 `merge` 하도록 준비만 해둔다.
원격 저장소의 모든 브랜치를 로컬에서 접근할 수 있어서 언제든지 `merge`를 하거나 내용을 살펴볼 수 있다.



### 11.2. pull

원격 저장소 브랜치에서 `fetch` 뿐만 아니라 `merge`까지 수행한다. 

- `$ git push`  을 사용할 때 다른 팀원이 해당 브랜치에 커밋 후 푸쉬를 해서 내가 작업하던 커밋이 뒤쳐져 있을 떄 아래와 같은 에러가 발생한다. 

  ```bash
  ! [rejected]        <branch-name> -> <branch-name> (non-fast-forward)
  error: failed to push some refs to '<repository-url>.git'
  hint: Updates were rejected because the tip of your current branch is behind
  hint: its remote counterpart. Merge the remote changes (e.g. 'git pull')
  hint: before pushing again.
  hint: See the 'Note about fast-forwards' in 'git push --help' for details.
  ```

  이 때 `pull`명령어를 사용하라는 힌트를 준다. `pull`을 사용하면 `merge`커밋이 생성되기 때문에 이와 같은 상황에서는 아래 명령어가 더 좋다 .

  ```bash
  $ git pull --rebase 
  ```

- `pull`

  ```bash
  $ git pull origin foo 
  $ git fetch origin foo; git merge origin foo 
  ```

  



## 12. 상대 참조 







### 13. source:Destination 





***



### 추가 

- 모든 브랜치 추가 

  ```bash
  git push origin --all
  ```

  